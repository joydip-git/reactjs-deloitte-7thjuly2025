 <Form
        inputHandler={handleFormInput}
        validationHandler={validate}
        show={showError}
	ref={inputElementRef}
      />

Form({inputHandler:handleFormInput,validationHandler:validate,show:showError})

forwardRef({inputHandler:handleFormInput,validationHandler:validate,show:showError},ref:RefObject)


Form({inputHandler:handleFormInput,validationHandler:validate,show:showError},ref:ForwardedRef)

forwardRef(), memo(), connect() etc. => Higher Order Component (design pattern)

forwardRef(component:Component, ref:any){ 
  return <Inner {...component} ref={ref}/>
}

component enhanced somehow => enhanced component (Exotic)

class and functional => functional
hooks


class App extends Component{
	state={
		counter:0,
		posts:[]
	}
	render(){
		return <></>
	}
}

const app = new App() => App component instance created

app.ref, props, state, key etc.
app.render() => returns React element (vdom)


<App ref={}/>

const App = fowardRef((props:any, ref:any)=>{
	return <li ref={ref}></>
})

Routing:
-------------------------------------
routing in react app (client-side) => 
	single page

DashBoard

http://localhost:4200/home	=> Home
http://localhost:4200/		=> Home


http://localhost:4200/products 			=> ProductList (collection of ProductInfo)
http://localhost:4200/products/view/{id}        => ProductDetail (display details of product with product id: {id})

http://localhost:4200/products/edit/{id}        => UpdateProduct (edit details of product with product id: {id})
http://localhost:4200/products/add 		=> AddProduct


inlvalid url					=> PageNotFound

route => path and component lazy/eager


react-router-dom and react-router (added transitively when the former is added)

router engine => 
	looks up to the browser and reads the url (path)
	write the url in the browser

routers -> 
	a. HashRouter => older browsers where information is stored as part of #
	b. BrowserRouter => for modern browsers, takes advantage of history api
	c. MemoryRouter	=> React Native, testing

hooks -> 
	useParams() => returns a read-only object with route parameters matching to the route that is currently active, containig all route parameters and their values as key/value pairs

	useNavigate() => returns a callback function which can be called to programmatically navigate to an url (equivalent to pushing the navigation url and data in the browser's history using history api)

	useRouter() => hook equivalent of <Routes> element to group different routes and even their children routes. Each route here is a RouteObject type (equivalent to <Route> component)

other components ->
	Link -> helps you navigate to an url (supply the nagigation url to "to" property of it) and additionally suppresses the default behavior of reloading the application of anchor element, submit button of form etc., which causes a request to be sent to the server and then bring a new page and then reload the application to render it


history api, location and params
pushState()	

{
  id:'100'	
}

{
  id:'100',
  x:'101'	
}


anchor -> navigate to 










